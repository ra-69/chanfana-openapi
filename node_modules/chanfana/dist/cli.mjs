#!/usr/bin/env node

// src/cli.ts
import { spawn } from "node:child_process";
import { writeFile } from "node:fs/promises";
import { join } from "node:path";
var READY_KEYWORD = "ready on";
var URL_REGEX = /ready on\s+(https?:\/\/[\w\.-]+:\d+)/i;
var outputFile = "schema.json";
var wranglerArgs = ["wrangler", "dev"];
var args = process.argv.slice(2);
for (let i = 0; i < args.length; i++) {
  if (args[i] === "-o" || args[i] === "--output") {
    if (i + 1 >= args.length) {
      console.error("Error: -o/--output requires a file path");
      process.exit(1);
    }
    const filePath = args[i + 1];
    if (!filePath) {
      console.error("Error: -o/--output file path cannot be empty");
      process.exit(1);
    }
    outputFile = filePath;
    i++;
  } else {
    wranglerArgs.push(args[i]);
  }
}
var resolvedOutputFile = join(process.cwd(), outputFile);
var childProcess = spawn("npx", wranglerArgs, {
  cwd: process.cwd(),
  stdio: ["inherit", "pipe", "pipe"],
  shell: true
});
var outputBuffer = [];
childProcess.stdout.on("data", (data) => {
  const line = data.toString().trim();
  outputBuffer.push(line);
});
childProcess.stderr.on("data", (data) => {
  const line = data.toString().trim();
  outputBuffer.push(`Error: ${line}`);
});
childProcess.stdout.on("data", async (data) => {
  const line = data.toString().trim();
  if (line.toLowerCase().includes(READY_KEYWORD)) {
    const match = line.match(URL_REGEX);
    if (match?.[1]) {
      const url = match[1];
      const request = new Request(`${url}/openapi.json`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        }
      });
      try {
        const response = await fetch(request);
        if (!response.ok) {
          console.error(`Error fetching schema: ${response.status} ${response.statusText}`);
          const body = await response.text();
          console.error("Response body:", body);
          console.error("Buffered output:", outputBuffer.join("\n"));
          childProcess.kill("SIGTERM");
          process.exit(1);
        }
        const schema = await response.json();
        if (schema.paths) {
          for (const path in schema.paths) {
            const pathObj = schema.paths[path];
            for (const method in pathObj) {
              if (pathObj[method]["x-ignore"] === true) {
                delete schema.paths[path];
                break;
              }
            }
          }
        }
        const schemaString = JSON.stringify(schema, null, 2);
        try {
          await writeFile(resolvedOutputFile, schemaString);
          console.log(`Schema written to ${resolvedOutputFile}`);
        } catch (err) {
          console.error(`Error writing schema to ${resolvedOutputFile}: ${err.message}`);
          console.error("Buffered output:", outputBuffer.join("\n"));
          childProcess.kill("SIGTERM");
          process.exit(1);
        }
        console.log("Successfully extracted schema");
        childProcess.kill("SIGTERM");
        process.exit(0);
      } catch (err) {
        console.error(`Fetch error: ${err.message}`);
        console.error("Buffered output:", outputBuffer.join("\n"));
        childProcess.kill("SIGTERM");
        process.exit(1);
      }
    } else {
      console.error(`No URL found in "ready on" line: ${line}`);
      console.error("Buffered output:", outputBuffer.join("\n"));
    }
  }
});
var timeoutId = setTimeout(() => {
  childProcess.kill("SIGTERM");
  console.error(`Command "npx wrangler dev" was never ready, exiting...`);
  console.error("Buffered output:", outputBuffer.join("\n"));
  process.exit(1);
}, 6e4);
var cleanup = () => {
  clearTimeout(timeoutId);
  if (!childProcess.killed) {
    childProcess.kill("SIGTERM");
    console.log("Cleaning up child process on exit");
  }
};
process.on("exit", cleanup);
process.on("SIGINT", () => {
  console.log("Received SIGINT (Ctrl+C), exiting...");
  cleanup();
  process.exit(0);
});
process.on("SIGTERM", () => {
  console.log("Received SIGTERM, exiting...");
  cleanup();
  process.exit(0);
});
process.on("uncaughtException", (err) => {
  console.error("Uncaught Exception:", err.message);
  console.error("Buffered output:", outputBuffer.join("\n"));
  cleanup();
  process.exit(1);
});
